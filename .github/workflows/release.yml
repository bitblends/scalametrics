name: Release

on:
  push:
    tags: ['v*']

permissions:
  id-token: write
  contents: write
  pull-requests: write

jobs:

  verify-tag:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Verify tag is on main
        id: verify
        run: |
          set -Eeuo pipefail
          echo "GITHUB_REF: $GITHUB_REF"
  
          # Ensure origin/main exists
          if ! git show-ref --verify --quiet refs/remotes/origin/main; then
            echo "::error::origin/main not found in repository."
            exit 1
          fi
  
          # Resolve commit of the tag (fail if not resolvable)
          if ! TAG_COMMIT=$(git rev-list -n 1 "$GITHUB_REF"); then
            echo "::error::Failed to resolve commit for ref $GITHUB_REF"
            exit 1
          fi
  
          # Ensure we actually got a commit hash
          if [ -z "$TAG_COMMIT" ]; then
            echo "::error::Empty commit resolved for ref $GITHUB_REF"
            exit 1
          fi
  
          # Check if this commit is reachable from main
          if git merge-base --is-ancestor "$TAG_COMMIT" origin/main; then
            echo "on_main=true" >> "$GITHUB_OUTPUT"
          else
            echo "on_main=false" >> "$GITHUB_OUTPUT"
          fi
      - name: Stop if not on main
        if: steps.verify.outputs.on_main == 'false'
        run: |
          echo "Tag is not on main. Skipping release."
          exit 0

  ##################
  # Create Release #
  ##################
  create-release:
    needs: verify-tag
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
          fetch-tags: true
      - name: Get Tag Message
        id: tag_message
        run: |
          TAG_MESSAGE=$(git tag -l --format='%(contents)' ${{ github.ref_name }})
          echo "$TAG_MESSAGE" > tag_message.txt
      - name: Gather PR Information and Generate Release Notes
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Initialize release notes
          echo "## Release ${{ github.ref_name }}" > release_notes.md
          echo "" >> release_notes.md
          
          # Add tag message
          if [ -s tag_message.txt ]; then
            echo "### ðŸ“ Release Notes" >> release_notes.md
            cat tag_message.txt >> release_notes.md
            echo "" >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          # Get previous tag (^ means parent commit of the tag)
          PREV_TAG=$(git describe --tags --abbrev=0 ${{ github.ref_name }}^ 2>/dev/null || echo "")

          # Get all commits between tags
          if [ -n "$PREV_TAG" ]; then
            COMMITS=$(git log --pretty=format:"%H" $PREV_TAG..${{ github.ref_name }})
          else
            COMMITS=$(git log --pretty=format:"%H" ${{ github.ref_name }})
          fi

          # Initialize arrays for categorized changes
          > features.txt
          > bugs.txt
          > docs.txt
          > ci.txt
          > chore.txt
          > style.txt
          > other.txt

          # Fetch recent merged PRs using GraphQL (we'll filter by commits later)
          PRS_JSON=$(gh api graphql -F owner="${{ github.repository_owner }}" -F name="${{ github.event.repository.name }}" -f query='
            query($owner: String!, $name: String!) {
              repository(owner: $owner, name: $name) {
                pullRequests(first: 100, states: MERGED, orderBy: {field: MERGED_AT, direction: DESC}) {
                  nodes {
                    number
                    title
                    labels(first: 10) { nodes { name } }
                    mergedAt
                    mergeCommit { oid }
                  }
                }
              }
            }
          ' | jq '.data.repository.pullRequests.nodes')

          # Filter and categorize PRs that are in our commit range
          echo "$PRS_JSON" | jq -c '.[]' | while read -r pr; do
            PR_NUMBER=$(echo "$pr" | jq -r '.number')
            PR_TITLE=$(echo "$pr" | jq -r '.title')
            PR_MERGE_COMMIT=$(echo "$pr" | jq -r '.mergeCommit.oid // empty')
            PR_LABELS=$(echo "$pr" | jq -r '.labels.nodes[].name // empty' | tr '\n' ' ')

            # Check if this PR's merge commit is in our commit range
            if [ -n "$PR_MERGE_COMMIT" ] && echo "$COMMITS" | grep -q "$PR_MERGE_COMMIT"; then
              if echo "$PR_LABELS" | grep -qE "feat|feature|enhancement"; then
                echo "- #$PR_NUMBER: $PR_TITLE" >> features.txt
              elif echo "$PR_LABELS" | grep -qE "bug|fix|bugfix"; then
                echo "- #$PR_NUMBER: $PR_TITLE" >> bugs.txt
              elif echo "$PR_LABELS" | grep -qE "documentation|docs"; then
                echo "- #$PR_NUMBER: $PR_TITLE" >> docs.txt
              elif echo "$PR_LABELS" | grep -qE "ci|cicd"; then
                echo "- #$PR_NUMBER: $PR_TITLE" >> ci.txt
              elif echo "$PR_LABELS" | grep -qE "chore|maintenance"; then
                echo "- #$PR_NUMBER: $PR_TITLE" >> chore.txt
              elif echo "$PR_LABELS" | grep -qE "style|formatting"; then
                echo "- #$PR_NUMBER: $PR_TITLE" >> style.txt
              else
                echo "- #$PR_NUMBER: $PR_TITLE" >> other.txt
              fi
            fi
          done
          
          # Optionally, handle commits not associated with PRs (if needed)
          
          # Build categorized changelog
          if [ -s features.txt ]; then
            echo "### ðŸš€ Features" >> release_notes.md
            cat features.txt >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -s bugs.txt ]; then
            echo "### ðŸž Bug Fixes" >> release_notes.md
            cat bugs.txt >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -s docs.txt ]; then
            echo "### ðŸ“š Documentation" >> release_notes.md
            cat docs.txt >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -s ci.txt ]; then
            echo "### âš™ï¸ CICD Changes" >> release_notes.md
            cat ci.txt >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -s chore.txt ]; then
            echo "### ðŸ§¹ Chore" >> release_notes.md
            cat chore.txt >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -s style.txt ]; then
            echo "### ðŸŽ¨ Style" >> release_notes.md
            cat style.txt >> release_notes.md
            echo "" >> release_notes.md
          fi
          
          if [ -s other.txt ]; then
            echo "### ðŸ”§ Other Changes" >> release_notes.md
            cat other.txt >> release_notes.md
          fi
          
          # Add footer with comparison link
          echo -e "\n\n---\n" >> release_notes.md
          if [ -n "$PREV_TAG" ]; then
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$PREV_TAG...${{ github.ref_name }}" >> release_notes.md
          fi

      - name: Create Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create ${{ github.ref_name }} \
            --title "Release ${{ github.ref_name }}" \
            --notes-file release_notes.md \
            --repo ${{ github.repository }}

  #######################
  # Publish to Sonatype #
  #######################
  publish:
    needs:
      - create-release
      - verify-tag
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Set up JDK 17
        uses: actions/setup-java@v5
        with:
          distribution: temurin
          java-version: 17
          cache: sbt
      - name: Setup SBT
        uses: sbt/setup-sbt@v1
      - name: Print Tag and Ref Info
        run: |
          echo "GITHUB_REF: $GITHUB_REF"
          echo "ref_name: ${{ github.ref_name }}"
      - name: Publish to Sonatype
        env:
          PGP_PASSPHRASE: ${{ secrets.PGP_PASSPHRASE }}
          PGP_SECRET: ${{ secrets.PGP_SECRET }}
          SONATYPE_PASSWORD: ${{ secrets.SONATYPE_PASSWORD }}
          SONATYPE_USERNAME: ${{ secrets.SONATYPE_USERNAME }}
        run: |
            echo "REF_NAME=${{ github.ref_name }}"
            sbt -v +ci-release

  ###################
  # Create Artifact #
  ###################
  create-artifact:
    needs: verify-tag
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Set up JDK 17
        uses: actions/setup-java@v5
        with:
          distribution: temurin
          java-version: 17
          cache: sbt
      - name: Setup SBT
        uses: sbt/setup-sbt@v1
      - name: Build ScalaDocs
        run: |
          cp LICENSE gh-pages/docs/
          cp DEVELOPMENT.md gh-pages/docs/
          cp CONTRIBUTING.md gh-pages/docs/
          cp CODE_OF_CONDUCT.md gh-pages/docs/
          sbt +doc
          cp -r target/scala-2.12/api gh-pages/docs/api-reference/2.12
          cp -r target/scala-2.13/api gh-pages/docs/api-reference/2.13
          cp -r target/scala-3.3.6/api gh-pages/docs/api-reference/3
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.10.19"
      - run: echo "cache_id=$(date --utc '+%V')" >> $GITHUB_ENV
      - uses: actions/cache@v4
        with:
          key: mkdocs-material-${{ env.cache_id }}
          path: ~/.cache
          restore-keys: |
            mkdocs-material-
      - name: Install mkdocs-material and generate static site
        env:
          PROJECT_VERSION: ${{ github.ref_name }}
        working-directory: ./gh-pages
        run: |
          pip install --no-input PyYAML
          pip install --no-input mkdocs-material
          pip install --no-input mkdocs-macros-plugin
          mkdocs build
      - name: Upload gh-pages artifact
        id: deployment
        uses: actions/upload-pages-artifact@v3
        with:
          name: github-pages
          path: gh-pages/site

  ################
  # Deploy Pages #
  ################
  deploy-gh-pages:
    needs: create-artifact
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    permissions:
      pages: write
      id-token: write
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4